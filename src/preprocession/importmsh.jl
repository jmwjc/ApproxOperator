
function getPhysicalGroups()
    entities = Dict{String,Tuple{Int,Int}}()
    dimTags = gmsh.model.getPhysicalGroups()
    for (dim,tag) in dimTags
        name = gmsh.model.getPhysicalName(dim,tag)
        tags = gmsh.model.getEntitiesForPhysicalGroup(dim,tag)
        entities[name] = (dim,tags[1])
    end
    return entities
end

function getùëø·µ¢()
    nodeTags, coord = gmsh.model.mesh.getNodes()
    n‚Çö = length(nodeTags)
    x = zeros(n‚Çö)
    y = zeros(n‚Çö)
    z = zeros(n‚Çö)
    for (i,I) in enumerate(nodeTags)
        x[I] = coord[3*i-2]
        y[I] = coord[3*i-1]
        z[I] = coord[3*i]
    end
    data = Dict([:x=>(1,x),:y=>(1,y),:z=>(1,z)])
    return [ùëø·µ¢((ùêº=i,),data) for i in 1:n‚Çö]
end

prequote = quote
    types = Dict([1=>:Seg2, 2=>:Tri3, 3=>:Quad, 4=>:Tet4, 8=>:Seg3, 9=>:Tri6, 10=>:Quad9, 11=>:Tet10, 15=>:Poi1, 16=>Quad8])
    dim, tag = dimTag
    elementTypes, ~, nodeTags = gmsh.model.mesh.getElements(dim,tag)
    elements = AbstractElement[]
end

coordinates = quote
    ng = length(weights)
    ne = Int(length(nodeTag)/ni)

    Œæ = localCoord[1:3:end]
    Œ∑ = localCoord[2:3:end]
    Œ≥ = localCoord[3:3:end]
    jacobians, determinants, coord = gmsh.model.mesh.getJacobians(elementType, localCoord, tag)
    x = coord[1:3:end]
    y = coord[2:3:end]
    z = coord[3:3:end]
    ùë§ = zeros(length(determinants))
    for i in 1:Int(length(determinants)/ng)
        for (j,w) in enumerate(weights)
            G = ng*(i-1)+j
            ùë§[G] = determinants[G]*w
        end
    end
    data = Dict([
        :w=>(1,weights),
        :x=>(2,x),
        :y=>(2,y),
        :z=>(2,z),
        :ùë§=>(2,ùë§),
    ])
    if dim == 3
        push!(data, :Œæ=>(1,Œæ), :Œ∑=>(1,Œ∑), :Œ≥=>(1,Œ≥))
    elseif dim == 2
        push!(data, :Œæ=>(1,Œæ), :Œ∑=>(1,Œ∑))
    else
        push!(data, :Œæ=>(1,Œæ))
    end
end

coordinatesForEdges = quote
    ng = length(weights)
    ne = Int(length(nodeTag)/ni)

    Œæ = zeros(ne*ng)
    Œ∑ = zeros(ne*ng)
    Œ≥ = zeros(ne*ng)
    n‚ÇÅ = zeros(ne)
    n‚ÇÇ = zeros(ne)
    s‚ÇÅ = zeros(ne)
    s‚ÇÇ = zeros(ne)
    Œî = zeros(ng)
    jacobians, determinants, coord = gmsh.model.mesh.getJacobians(elementType, localCoord, tag)
    x = coord[1:3:end]
    y = coord[2:3:end]
    z = coord[3:3:end]
    ùë§ = zeros(length(determinants))
    for i in 1:Int(length(determinants)/ng)
        for (j,w) in enumerate(weights)
            G = ng*(i-1)+j
            ùë§[G] = determinants[G]*w
        end
    end

    for g in 1:ng
        Œæg = localCoord[3*g-2]
        if Œæg ‚âà 1.0
            Œî[g] = 1.0
        elseif Œæg ‚âà -1.0
            Œî[g] = -1.0
        else
            Œî[g] = 0.0
        end
    end

    nodeTags = gmsh.model.mesh.getElementEdgeNodes(elementType,tag,true)
    dimŒ©,tagŒ© = dimTagŒ©
    ~, tagsŒ© = gmsh.model.mesh.getElements(dimŒ©,tagŒ©)
    for (CŒ©,tagŒ©) in enumerate(tagsŒ©[1])
        for C in 3*CŒ©-2:3*CŒ©
            ùêø = 2*determinants[C*ng]
            coord, = gmsh.model.mesh.getNode(nodeTags[2*C-1])
            x‚ÇÅ = coord[1]
            y‚ÇÅ = coord[2]
            coord, = gmsh.model.mesh.getNode(nodeTags[2*C])
            x‚ÇÇ = coord[1]
            y‚ÇÇ = coord[2]
            n‚ÇÅ[C] = (y‚ÇÇ-y‚ÇÅ)/ùêø
            n‚ÇÇ[C] = (x‚ÇÅ-x‚ÇÇ)/ùêø
            s‚ÇÅ[C] = -n‚ÇÇ[C]
            s‚ÇÇ[C] =  n‚ÇÅ[C]
            for g in 1:ng
                G = ng*(C-1)+g
                Œæ[G], Œ∑[G], Œ≥[G] = gmsh.model.mesh.getLocalCoordinatesInElement(tagŒ©, x[G], y[G], z[G])
            end
        end
    end
    data = Dict([
        :w=>(1,weights),
        :x=>(2,x),
        :y=>(2,y),
        :z=>(2,z),
        :ùë§=>(2,ùë§),
        :n‚ÇÅ=>(3,n‚ÇÅ),
        :n‚ÇÇ=>(3,n‚ÇÇ),
        :s‚ÇÅ=>(3,s‚ÇÅ),
        :s‚ÇÇ=>(3,s‚ÇÇ),
        :Œî=>(1,Œî),
    ])
    if dim == 2
        push!(data, :Œæ=>(1,Œæ), :Œ∑=>(1,Œ∑), :Œ≥=>(1,Œ≥))
    else
        push!(data, :Œæ=>(1,Œæ), :Œ∑=>(1,Œ∑))
    end
end

curvilinearCoordinates = quote
    ng = length(weights)
    ne = Int(length(nodeTag)/ni)

    Œæ = localCoord[1:3:end]
    Œ∑ = localCoord[2:3:end]
    Œ≥ = localCoord[3:3:end]
    jacobians, determinants, coord = gmsh.model.mesh.getJacobians(elementType, localCoord, tag)
    x = coord[1:3:end]
    y = coord[2:3:end]
    z = coord[3:3:end]
    ùë§ = zeros(length(determinants))
    if dim == 2
        for i in 1:Int(length(determinants)/ng)
            for (j,w) in enumerate(weights)
                G = ng*(i-1)+j
                x_ = Vec{3}((x[G],y[G],z[G]))
                # J1 = ùêΩ(x_)
                # J2 = cos(y[G]/25)
                # println("J1: $J1, J2: $J2")
                ùë§[G] = determinants[G]*cs.ùêΩ(x_)*w
            end
        end
        data = Dict([
            :w=>(1,weights),
            :x=>(2,x),
            :y=>(2,y),
            :z=>(2,z),
            :ùë§=>(2,ùë§),
        ])
    elseif dim == 1
        Œî = zeros(ng)
        ‚àÇx‚àÇŒæ = jacobians[1:9:end]
        ‚àÇy‚àÇŒæ = jacobians[2:9:end]
        ‚àÇz‚àÇŒæ = jacobians[3:9:end]
        n‚ÇÅ = zeros(ne*ng)
        n‚ÇÇ = zeros(ne*ng)
        n¬π = zeros(ne*ng)
        n¬≤ = zeros(ne*ng)
        s‚ÇÅ = zeros(ne*ng)
        s‚ÇÇ = zeros(ne*ng)
        s¬π = zeros(ne*ng)
        s¬≤ = zeros(ne*ng)
        ‚àÇ‚ÇÅn‚ÇÅ = zeros(ne*ng)
        ‚àÇ‚ÇÅn‚ÇÇ = zeros(ne*ng)
        ‚àÇ‚ÇÇn‚ÇÅ = zeros(ne*ng)
        ‚àÇ‚ÇÇn‚ÇÇ = zeros(ne*ng)
        ‚àÇ‚ÇÅs‚ÇÅ = zeros(ne*ng)
        ‚àÇ‚ÇÅs‚ÇÇ = zeros(ne*ng)
        ‚àÇ‚ÇÇs‚ÇÅ = zeros(ne*ng)
        ‚àÇ‚ÇÇs‚ÇÇ = zeros(ne*ng)
        nodeTags = gmsh.model.mesh.getElementEdgeNodes(elementType, tag, true)
        for C in 1:ne
            ùêø = 2*determinants[C*ng]
            coord, = gmsh.model.mesh.getNode(nodeTags[2*C-1])
            x‚ÇÅ = coord[1]
            y‚ÇÅ = coord[2]
            coord, = gmsh.model.mesh.getNode(nodeTags[2*C])
            x‚ÇÇ = coord[1]
            y‚ÇÇ = coord[2]
            t¬π = (x‚ÇÇ-x‚ÇÅ)/ùêø
            t¬≤ = (y‚ÇÇ-y‚ÇÅ)/ùêø
            t‚ÇÅ(x) = cs.a‚ÇÅ‚ÇÅ(x)*t¬π + cs.a‚ÇÅ‚ÇÇ(x)*t¬≤
            t‚ÇÇ(x) = cs.a‚ÇÅ‚ÇÇ(x)*t¬π + cs.a‚ÇÇ‚ÇÇ(x)*t¬≤
            t(x) = (t‚ÇÅ(x)*t¬π + t‚ÇÇ(x)*t¬≤)^0.5
            s¬π_(x) = t¬π/t(x)
            s¬≤_(x) = t¬≤/t(x)
            s‚ÇÅ_(x) = t‚ÇÅ(x)/t(x)
            s‚ÇÇ_(x) = t‚ÇÇ(x)/t(x)
            deta(x) = (cs.a‚ÇÅ‚ÇÅ(x)*cs.a‚ÇÇ‚ÇÇ(x) - cs.a‚ÇÅ‚ÇÇ(x)^2)^0.5
            n‚ÇÅ_(x) = s¬≤_(x)*deta(x)
            n‚ÇÇ_(x) =-s¬π_(x)*deta(x)
            n¬π_(x) = cs.a¬π¬π(x)*n‚ÇÅ_(x) + cs.a¬π¬≤(x)*n‚ÇÇ_(x)
            n¬≤_(x) = cs.a¬π¬≤(x)*n‚ÇÅ_(x) + cs.a¬≤¬≤(x)*n‚ÇÇ_(x)
            ‚àÇ‚ÇÅn‚ÇÅ_(x) = gradient(n‚ÇÅ_,x)[1]
            ‚àÇ‚ÇÇn‚ÇÅ_(x) = gradient(n‚ÇÅ_,x)[2]
            ‚àÇ‚ÇÅn‚ÇÇ_(x) = gradient(n‚ÇÇ_,x)[1]
            ‚àÇ‚ÇÇn‚ÇÇ_(x) = gradient(n‚ÇÇ_,x)[2]
            ‚àÇ‚ÇÅs‚ÇÅ_(x) = gradient(s‚ÇÅ_,x)[1]
            ‚àÇ‚ÇÇs‚ÇÅ_(x) = gradient(s‚ÇÅ_,x)[2]
            ‚àÇ‚ÇÅs‚ÇÇ_(x) = gradient(s‚ÇÇ_,x)[1]
            ‚àÇ‚ÇÇs‚ÇÇ_(x) = gradient(s‚ÇÇ_,x)[2]
            for (j,w) in enumerate(weights)
                G = ng*(C-1)+j
                x_ = Vec{3}((x[G],y[G],z[G]))
                ùíÇ‚ÇÅ_ = cs.ùíÇ‚ÇÅ(x_)
                ùíÇ‚ÇÇ_ = cs.ùíÇ‚ÇÇ(x_)
                ùíÇ‚ÇÉ_ = cs.ùíÇ‚ÇÉ(x_)
                J = ((ùíÇ‚ÇÅ_[1]*‚àÇx‚àÇŒæ[G] + ùíÇ‚ÇÇ_[1]*‚àÇy‚àÇŒæ[G] + ùíÇ‚ÇÉ_[1]*‚àÇz‚àÇŒæ[G])^2
                  +  (ùíÇ‚ÇÅ_[2]*‚àÇx‚àÇŒæ[G] + ùíÇ‚ÇÇ_[2]*‚àÇy‚àÇŒæ[G] + ùíÇ‚ÇÉ_[2]*‚àÇz‚àÇŒæ[G])^2
                  +  (ùíÇ‚ÇÅ_[3]*‚àÇx‚àÇŒæ[G] + ùíÇ‚ÇÇ_[3]*‚àÇy‚àÇŒæ[G] + ùíÇ‚ÇÉ_[3]*‚àÇz‚àÇŒæ[G])^2)^0.5
                s‚ÇÅ[G] = s‚ÇÅ_(x_)
                s‚ÇÇ[G] = s‚ÇÇ_(x_)
                s¬π[G] = s¬π_(x_)
                s¬≤[G] = s¬≤_(x_)
                n‚ÇÅ[G] = n‚ÇÅ_(x_)
                n‚ÇÇ[G] = n‚ÇÇ_(x_)
                n¬π[G] = n¬π_(x_)
                n¬≤[G] = n¬≤_(x_)
                ‚àÇ‚ÇÅn‚ÇÅ[G] = ‚àÇ‚ÇÅn‚ÇÅ_(x_)
                ‚àÇ‚ÇÅn‚ÇÇ[G] = ‚àÇ‚ÇÅn‚ÇÇ_(x_)
                ‚àÇ‚ÇÇn‚ÇÅ[G] = ‚àÇ‚ÇÇn‚ÇÅ_(x_)
                ‚àÇ‚ÇÇn‚ÇÇ[G] = ‚àÇ‚ÇÇn‚ÇÇ_(x_)
                ‚àÇ‚ÇÅs‚ÇÅ[G] = ‚àÇ‚ÇÅs‚ÇÅ_(x_)
                ‚àÇ‚ÇÅs‚ÇÇ[G] = ‚àÇ‚ÇÅs‚ÇÇ_(x_)
                ‚àÇ‚ÇÇs‚ÇÅ[G] = ‚àÇ‚ÇÇs‚ÇÅ_(x_)
                ‚àÇ‚ÇÇs‚ÇÇ[G] = ‚àÇ‚ÇÇs‚ÇÇ_(x_)
                # det = determinants[G]
                # println("determinant: $det, ùêΩ: $J.")
                ùë§[G] = J*w
            end
        end
        for g in 1:ng
            Œæg = localCoord[3*g-2]
            if Œæg ‚âà 1.0
                Œî[g] = 1.0
            elseif Œæg ‚âà -1.0
                Œî[g] = -1.0
            else
                Œî[g] = 0.0
            end
        end
        data = Dict([
            :w=>(1,weights),
            :x=>(2,x),
            :y=>(2,y),
            :z=>(2,z),
            :ùë§=>(2,ùë§),
            :n‚ÇÅ=>(2,n‚ÇÅ),
            :n‚ÇÇ=>(2,n‚ÇÇ),
            :n¬π=>(2,n¬π),
            :n¬≤=>(2,n¬≤),
            :s‚ÇÅ=>(2,s‚ÇÅ),
            :s‚ÇÇ=>(2,s‚ÇÇ),
            :s¬π=>(2,s¬π),
            :s¬≤=>(2,s¬≤),
            :‚àÇ‚ÇÅn‚ÇÅ=>(2,‚àÇ‚ÇÅn‚ÇÅ),
            :‚àÇ‚ÇÅn‚ÇÇ=>(2,‚àÇ‚ÇÅn‚ÇÇ),
            :‚àÇ‚ÇÇn‚ÇÅ=>(2,‚àÇ‚ÇÇn‚ÇÅ),
            :‚àÇ‚ÇÇn‚ÇÇ=>(2,‚àÇ‚ÇÇn‚ÇÇ),
            :‚àÇ‚ÇÅs‚ÇÅ=>(2,‚àÇ‚ÇÅs‚ÇÅ),
            :‚àÇ‚ÇÅs‚ÇÇ=>(2,‚àÇ‚ÇÅs‚ÇÇ),
            :‚àÇ‚ÇÇs‚ÇÅ=>(2,‚àÇ‚ÇÇs‚ÇÅ),
            :‚àÇ‚ÇÇs‚ÇÇ=>(2,‚àÇ‚ÇÇs‚ÇÇ),
            :Œî=>(1,Œî),
        ])
    end
    if dim == 2
        push!(data, :Œæ=>(1,Œæ), :Œ∑=>(1,Œ∑))
    else
        push!(data, :Œæ=>(1,Œæ))
    end
end

cal_length_area_volume = quote
    if elementType == 1
        ùêø = [2*determinants[C*ng] for C in 1:ne]
        push!(data, :ùêø=>(3,ùêø))
    elseif elementType == 2
        ùê¥ = [determinants[C*ng]/2 for C in 1:ne]
        push!(data, :ùê¥=>(3,ùê¥))
    end
end

typeForFEM = quote
    type = Element{types[elementType]}
end

cal_normal = quote
    if normal
        nodeTags = gmsh.model.mesh.getElementEdgeNodes(elementType,tag,true)
        if dim == 1
            n‚ÇÅ = zeros(ne)
            n‚ÇÇ = zeros(ne)
            s‚ÇÅ = zeros(ne)
            s‚ÇÇ = zeros(ne)
            for C in 1:ne
                ùêø = 2*determinants[C*ng]
                coord, = gmsh.model.mesh.getNode(nodeTags[2*C-1])
                x‚ÇÅ = coord[1]
                y‚ÇÅ = coord[2]
                coord, = gmsh.model.mesh.getNode(nodeTags[2*C])
                x‚ÇÇ = coord[1]
                y‚ÇÇ = coord[2]
                n‚ÇÅ[C] = (y‚ÇÇ-y‚ÇÅ)/ùêø
                n‚ÇÇ[C] = (x‚ÇÅ-x‚ÇÇ)/ùêø
                s‚ÇÅ[C] = -n‚ÇÇ[C]
                s‚ÇÇ[C] =  n‚ÇÅ[C]
            end
            push!(data,:n‚ÇÅ=>(3,n‚ÇÅ),:n‚ÇÇ=>(3,n‚ÇÇ),:s‚ÇÅ=>(3,s‚ÇÅ),:s‚ÇÇ=>(3,s‚ÇÇ))
        end
    end
end

integrationByGmsh = quote
    ~, ~, order, ni = gmsh.model.mesh.getElementProperties(elementType)
    if integrationOrder < 0 integrationOrder = order end
    integrationType = "Gauss"*string(integrationOrder)
    localCoord, weights = gmsh.model.mesh.getIntegrationPoints(elementType,integrationType)
end

integrationByManual = quote
    ~, ~, ~, ni = gmsh.model.mesh.getElementProperties(elementType)
    localCoord, weights = integration
end

generateForFEM = quote
    G = 0
    s = 0
    for C in 1:ne
        ùìí = nodes[nodeTag[ni*(C-1)+1:ni*C]]
        ùìñ = [ùëø‚Çõ((ùëî = g, ùê∫ = G+g, ùê∂ = C, ùë† = s+(g-1)*ni), data) for g in 1:ng]
        G += ng
        s += ng*ni
        push!(elements,type(ùìí,ùìñ))
    end
end

generateForNeighbor = quote
    G = 0
    s = 0
    for C in 1:ne
        indices = Set{Int}()
        for g in 1:ng
            x·µ¢ = x[G+g]
            y·µ¢ = y[G+g]
            z·µ¢ = z[G+g]
            union!(indices,sp(x·µ¢,y·µ¢,z·µ¢))
        end
        ni = length(indices)
        ùìí = [nodes[i] for i in indices]
        ùìñ = [ùëø‚Çõ((ùëî = g, ùê∫ = G+g, ùê∂ = C, ùë† = s+(g-1)*ni), data) for g in 1:ng]
        G += ng
        s += ng*ni
        push!(elements,type(ùìí,ùìñ))
    end
end

generateForMarco = quote
    elements = Vector{type}(undef,ne)
    dataùìí = Dict{Symbol,Tuple{Int,Vector{Float64}}}()
    ni = getùëõùëù(type(ùëø·µ¢[],ùëø‚Çõ[]))
    n‚ÇÅ = Int(round(n/n‚Çï))
    n‚ÇÇ = Int(round(ne/n‚Çê/n‚ÇÅ/n‚Çï^2))
    for j in 1:n‚ÇÇ
        for i in 1:n‚ÇÅ
            ùìí = [ùëø·µ¢((ùêº=n‚ÇÅ*ni*(j-1)+ni*(i-1)+k,),dataùìí) for k in 1:ni]
            for k in 1:n‚Çï
                for l in 1:n‚Çê*n‚Çï
                    C = n‚Çê*n‚Çï*n‚ÇÅ*(n‚Çï*(j-1)+k-1)+n‚Çê*n‚Çï*(i-1)+l
                    G = ng*(C-1)
                    s = G*ni
                    ùìñ = [ùëø‚Çõ((ùëî = g, ùê∫ = G+g, ùê∂ = C, ùë† = s+(g-1)*ni), data) for g in 1:ng]
                    elements[C] = type(ùìí,ùìñ)
                end
            end
        end
    end
end

generateForPiecewise = quote
    G = 0
    s = 0
    dataùìí = Dict{Symbol,Tuple{Int,Vector{Float64}}}()
    ni = getùëõùëù(type(ùëø·µ¢[],ùëø‚Çõ[]))
    for i in 1:Int(ne/nb)
        ùìí = [ùëø·µ¢((ùêº=ni*(i-1)+j,),dataùìí) for j in 1:ni]
        for j in 1:nb
            C = nb*(i-1)+j
            ùìñ = [ùëø‚Çõ((ùëî = g, ùê∫ = G+g, ùê∂ = C, ùë† = s+(g-1)*ni), data) for g in 1:ng]
            G += ng
            s += ng*ni
            push!(elements,type(ùìí,ùìñ))
        end
    end
end

generateSummary = quote
    println("Info: Generate $ne elements of $type with $ng integration points.")
end

@eval begin

function getElements(nodes::Vector{N},dimTag::Tuple{Int,Int},integrationOrder::Int = -1;normal::Bool=false) where N<:Node
    $prequote
    for (elementType,nodeTag) in zip(elementTypes,nodeTags)
        ## element type
        $typeForFEM
        ## integration rule
        $integrationByGmsh
        ## coordinates
        $coordinates
        ## special variables
        $cal_length_area_volume # length area and volume
        $cal_normal # unit outernal normal
        ## generate element
        $generateForFEM
        ## summary
        $generateSummary
    end
    return elements
end

function getElements(nodes::Vector{N},dimTag::Tuple{Int,Int},integration::NTuple{2,Vector{Float64}};normal::Bool=false) where N<:Node
    $prequote
    for (elementType,nodeTag) in zip(elementTypes,nodeTags)
        ## element type
        $typeForFEM
        ## integration rule
        $integrationByManual
        ## coordiantes
        $coordinates
        ## special variables
        $cal_length_area_volume # length area and volume
        $cal_normal # unit outernal normal
        ## generate element
        $generateForFEM
        ## summary
        $generateSummary
    end
    return elements
end

function getElements(nodes::Vector{N},dimTag::Tuple{Int,Int},type::DataType,integrationOrder::Int = -1;normal::Bool=false) where N<:Node
    $prequote
    for (elementType,nodeTag) in zip(elementTypes,nodeTags)
        ## integration rule
        $integrationByGmsh
        ## coordinates
        $coordinates
        ## special variables
        $cal_length_area_volume # length area and volume
        $cal_normal # unit outernal normal
        ## generate element
        $generateForFEM
        ## summary
        $generateSummary
    end
    return elements
end

function getElements(nodes::Vector{N},dimTag::Tuple{Int,Int},type::DataType,integration::NTuple{2,Vector{Float64}};normal::Bool=false) where N<:Node
    $prequote
    for (elementType,nodeTag) in zip(elementTypes,nodeTags)
        ## integration rule
        $integrationByManual
        ## coordiantes
        $coordinates
        ## special variables
        $cal_length_area_volume # length area and volume
        $cal_normal # unit outernal normal
        ## generate element
        $generateForFEM
        ## summary
        $generateSummary
    end
    return elements
end

function getElements(nodes::Vector{N},dimTag::Tuple{Int,Int},type::DataType,integrationOrder::Int,sp::SpatialPartition;normal::Bool=false) where N<:Node
    $prequote
    for (elementType,nodeTag) in zip(elementTypes,nodeTags)
        ## integration rule
        $integrationByGmsh
        ## coordinates
        $coordinates
        ## special variables
        $cal_length_area_volume # length area and volume
        $cal_normal # unit outernal normal
        ## generate element
        $generateForNeighbor
        ## summary
        $generateSummary
    end
    return elements
end

function getElements(nodes::Vector{N},dimTag::Tuple{Int,Int},type::DataType,integration::NTuple{2,Vector{Float64}},sp::SpatialPartition;normal::Bool=false) where N<:Node
    $prequote
    for (elementType,nodeTag) in zip(elementTypes,nodeTags)
        ## integration rule
        $integrationByManual
        ## coordinates
        $coordinates
        ## special variables
        $cal_length_area_volume # length area and volume
        $cal_normal # unit outernal normal
        ## generate element
        $generateForNeighbor
        ## summary
        $generateSummary
    end
    return elements
end

function getMacroElements(dimTag::Tuple{Int,Int},type::DataType,integrationOrder::Int,n::Int;n‚Çï::Int=1,n‚Çê::Int=2)
    $prequote
    for (elementType,nodeTag) in zip(elementTypes,nodeTags)
        ## integration rule
        $integrationByGmsh
        ## coordinates
        $coordinates
        ## special variables
        $cal_length_area_volume # length area and volume
        ## generate element
        $generateForPiecewise
        ## summary
        $generateSummary
    end
    return elements
end

function getMacroElements(dimTag::Tuple{Int,Int},type::DataType,integration::NTuple{2,Vector{Float64}},n::Int;n‚Çï::Int=1,n‚Çê::Int=2)
    $prequote
    for (elementType,nodeTag) in zip(elementTypes,nodeTags)
        ## integration rule
        $integrationByManual
        ## coordinates
        $coordinates
        ## special variables
        $cal_length_area_volume # length area and volume
        ## generate element
        $generateForPiecewise
        ## summary
        $generateSummary
    end
    return elements
end

function getMacroBoundaryElements(dimTag::Tuple{Int,Int},dimTagŒ©::Tuple{Int,Int},type::DataType,integrationOrder::Int,n::Int;n‚Çï::Int=1,n‚Çê::Int=6)
    $prequote
    for (elementType,nodeTag) in zip(elementTypes,nodeTags)
        ## integration rule
        $integrationByGmsh
        ## coordinates
        $coordinatesForEdges
        ## special variables
        $cal_length_area_volume # length area and volume
        ## generate element
        $generateForPiecewise
        ## summary
        $generateSummary
    end
    return elements
end

function getMacroBoundaryElements(dimTag::Tuple{Int,Int},dimTagŒ©::Tuple{Int,Int},type::DataType,integration::NTuple{2,Vector{Float64}},n::Int;n‚Çï::Int=1,n‚Çê::Int=6)
    $prequote
    for (elementType,nodeTag) in zip(elementTypes,nodeTags)
        ## integration rule
        $integrationByManual
        ## coordinates
        $coordinatesForEdges
        ## special variables
        $cal_length_area_volume # length area and volume
        ## generate element
        $generateForPiecewise
        ## summary
        $generateSummary
    end
    return elements
end

function getCurvedElements(nodes::Vector{N},dimTag::Tuple{Int,Int},cs::Function,integrationOrder::Int = -1) where N<:Node
    $prequote
    for (elementType,nodeTag) in zip(elementTypes,nodeTags)
        ## element type
        $typeForFEM
        ## integration rule
        $integrationByGmsh
        ## coordinates
        $curvilinearCoordinates
        ## special variables
        $cal_length_area_volume # length area and volume
        ## generate element
        $generateForFEM
        ## summary
        $generateSummary
    end
    return elements
end

function getCurvedElements(nodes::Vector{N},dimTag::Tuple{Int,Int},cs::Function,integration::NTuple{2,Vector{Float64}}) where N<:Node
    $prequote
    for (elementType,nodeTag) in zip(elementTypes,nodeTags)
        ## element type
        $typeForFEM
        ## integration rule
        $integrationByManual
        ## coordinates
        $curvilinearCoordinates
        ## special variables
        $cal_length_area_volume # length area and volume
        ## generate element
        $generateForFEM
        ## summary
        $generateSummary
    end
    return elements
end

function getCurvedElements(nodes::Vector{N},dimTag::Tuple{Int,Int},type::DataType,cs::Function,integrationOrder::Int,sp::SpatialPartition) where N<:Node
    $prequote
    for (elementType,nodeTag) in zip(elementTypes,nodeTags)
        ## integration rule
        $integrationByGmsh
        ## coordinates
        $curvilinearCoordinates
        ## special variables
        $cal_length_area_volume # length area and volume
        ## generate element
        $generateForNeighbor
        ## summary
        $generateSummary
    end
    return elements
end

function getCurvedElements(nodes::Vector{N},dimTag::Tuple{Int,Int},type::DataType,cs::Function,integration::NTuple{2,Vector{Float64}},sp::SpatialPartition) where N<:Node
    $prequote
    for (elementType,nodeTag) in zip(elementTypes,nodeTags)
        ## integration rule
        $integrationByManual
        ## coordinates
        $curvilinearCoordinates
        ## special variables
        $cal_length_area_volume # length area and volume
        ## generate element
        $generateForNeighbor
        ## summary
        $generateSummary
    end
    return elements
end

function getCurvedPiecewiseElements(dimTag::Tuple{Int,Int},type::DataType,cs::Function,integrationOrder::Int,nb::Int=1)
    $prequote
    for (elementType,nodeTag) in zip(elementTypes,nodeTags)
        ## integration rule
        $integrationByGmsh
        ## coordinates
        $curvilinearCoordinates
        ## special variables
        $cal_length_area_volume # length area and volume
        ## generate element
        $generateForPiecewise
        ## summary
        $generateSummary
    end
    return elements
end

function getCurvedPiecewiseElements(dimTag::Tuple{Int,Int},type::DataType,cs::Function,integration::NTuple{2,Vector{Float64}},nb::Int=1)
    $prequote
    for (elementType,nodeTag) in zip(elementTypes,nodeTags)
        ## integration rule
        $integrationByManual
        ## coordinates
        $curvilinearCoordinates
        ## special variables
        $cal_length_area_volume # length area and volume
        ## generate element
        $generateForPiecewise
        ## summary
        $generateSummary
    end
    return elements
end

end 
